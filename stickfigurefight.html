<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stick Fighter: Melee Levels 1-50</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f17; color:#e8eefc; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #wrap { display:grid; grid-template-columns: 1fr 320px; height:100%; }
    canvas { width:100%; height:100%; display:block; background: radial-gradient(circle at 50% 20%, #17233a 0%, #0b0f17 65%); }
    #ui {
      border-left: 1px solid rgba(255,255,255,0.08);
      padding: 14px 14px 10px;
      overflow:auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));
    }
    h1 { font-size: 16px; margin: 0 0 10px; letter-spacing: .3px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 8px 0; }
    .pill { font-size: 12px; padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.10); }
    .bar { height: 10px; border-radius: 999px; background: rgba(255,255,255,0.10); overflow:hidden; border: 1px solid rgba(255,255,255,0.10); }
    .bar > div { height:100%; width:50%; background: rgba(120,200,255,0.9); }
    .bar.red > div { background: rgba(255,110,110,0.95); }
    .muted { color: rgba(232,238,252,0.75); font-size: 12px; line-height: 1.35; }
    .shop { margin-top: 12px; }
    .card {
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 10px;
      margin: 10px 0;
    }
    .card h2 { font-size: 13px; margin:0 0 6px; }
    button {
      cursor:pointer;
      width:100%;
      margin-top: 8px;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.07);
      color:#e8eefc;
      font-weight: 650;
    }
    button:disabled { opacity: 0.45; cursor:not-allowed; }
    kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
          font-size: 11px; padding: 2px 6px; border-radius: 6px;
          border: 1px solid rgba(255,255,255,0.18); background: rgba(0,0,0,0.25); }
    .tiny { font-size: 11px; color: rgba(232,238,252,0.72); }
    .sep { height:1px; background: rgba(255,255,255,0.08); margin: 10px 0; }
    .hint { font-size: 12px; }
    .good { color: #a6ffcb; }
    .warn { color: #ffd48a; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <div id="ui">
    <h1>Stick Fighter</h1>

    <div class="row">
      <span class="pill">Move: <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></span>
      <span class="pill">Punch: <kbd>Space</kbd></span>
      <span class="pill">Kick: <kbd>K</kbd></span>
    </div>

    <div class="row">
      <span class="pill">Dash: <kbd>F</kbd></span>
      <span class="pill">Tree: <kbd>R</kbd></span>
      <span class="pill">Shield: <kbd>E</kbd></span>
    </div>

    <div class="sep"></div>

    <div class="row">
      <div style="flex:1">
        <div class="tiny">Player HP</div>
        <div class="bar red"><div id="hpBar"></div></div>
      </div>
      <div style="flex:1">
        <div class="tiny">Level progress</div>
        <div class="bar"><div id="xpBar"></div></div>
      </div>
    </div>

    <div class="row">
      <span class="pill">Points: <b id="points">0</b></span>
      <span class="pill">Level: <b id="wave">1</b> / 50</span>
      <span class="pill">Kills: <b id="kills">0</b></span>
    </div>

    <div class="muted" id="shopHint">
      Defeat all enemies to pass. Buy upgrades only between levels (after pass or lose). Points never reset.
    </div>

    <div class="shop">
      <div class="card">
        <h2>Dash (<kbd>F</kbd>)</h2>
        <div class="muted">Quick burst movement. Cooldown 2.0s.</div>
        <button id="buyDash">Buy Dash (25)</button>
      </div>

      <div class="card">
        <h2>Summon Tree (<kbd>R</kbd>)</h2>
        <div class="muted">Spawns a blocking tree for 6s. Cooldown 5.0s.</div>
        <button id="buyTree">Buy Tree (35)</button>
      </div>

      <div class="card">
        <h2>Shield (<kbd>E</kbd>)</h2>
        <div class="muted">Reduces damage for 3s. Cooldown 7.0s.</div>
        <button id="buyShield">Buy Shield (45)</button>
      </div>

      <div class="card">
        <h2>Upgrade: Max HP</h2>
        <div class="muted">Increase max HP by +20 (stacks).</div>
        <button id="buyHP">Buy +20 HP (30)</button>
      </div>

      <div class="card">
        <h2>Upgrade: Damage</h2>
        <div class="muted">Increase punch/kick damage (stacks).</div>
        <button id="buyDmg">Buy +2 Damage (30)</button>
      </div>

      <div class="card">
        <h2>Upgrade: Move Speed</h2>
        <div class="muted">Run faster (stacks).</div>
        <button id="buySpd">Buy +0.2 Speed (30)</button>
      </div>

      <div class="sep"></div>
      <div class="muted hint" id="betweenLevelsHint">
        Shop is only open when you pass or fail a level. Points are kept forever.
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ---------- Canvas / Scaling ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  window.addEventListener('resize', resize);

  // ---------- UI ----------
  const elPoints = document.getElementById('points');
  const elWave = document.getElementById('wave');
  const elKills = document.getElementById('kills');
  const hpBar = document.getElementById('hpBar');
  const xpBar = document.getElementById('xpBar');

  // ---------- Input ----------
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    keys.add(e.key.toLowerCase());
    if (e.key === 'Enter') {
      if (state.gameOver) retryLevel();
      else if (state.levelComplete) nextLevel();
      else if (!state.playing && state.killsThisLevel === 0 && !state.levelComplete) startLevel();
    }
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

  const mouse = { x: 0, y: 0, down: false };
  canvas.addEventListener('mousemove', (e) => {
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left);
    mouse.y = (e.clientY - r.top);
  });
  canvas.addEventListener('mousedown', () => mouse.down = true);
  window.addEventListener('mouseup', () => mouse.down = false);

  // ---------- Helpers ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (ax, ay, bx, by) => {
    const dx = ax - bx, dy = ay - by;
    return dx*dx + dy*dy;
  };

  // Simple rectangle collision
  function rectsOverlap(a,b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // ---------- Game State ----------
  const state = {
    points: 0,           // never reset; only spent in shop
    level: 1,           // 1 to 50
    killsThisLevel: 0,
    levelKillTarget: 0, // set per level
    gameOver: false,    // died this level
    levelComplete: false,
    playing: false,     // false = between levels, shop open
    lastTime: 0,
    spawnTimer: 0,
    powerTimer: 0,
    messageTimer: 0,
    message: "",
  };

  // Entities
  let player, enemies, obstacles, powerups, particles;

  // Shop / Abilities (locked until bought); only purchasable when !state.playing
  const abilities = {
    dash: { owned: false, cd: 2.0, t: 0 },
    tree: { owned: false, cd: 5.0, t: 0 },
    shield:{ owned: false, cd: 7.0, t: 0, active: 0 },
  };

  // ---------- Level / Game Flow ----------
  const MAX_LEVEL = 50;

  function startLevel() {
    state.playing = true;
    state.gameOver = false;
    state.levelComplete = false;
    state.killsThisLevel = 0;
    state.spawnTimer = 0;
    state.powerTimer = 0;
    state.messageTimer = 0;
    state.message = "";
    // kill target for this level
    state.levelKillTarget = 2 + Math.floor(state.level * 1.4);

    for (const k in abilities) abilities[k].t = 0;
    abilities.shield.active = 0;

    const cw = canvas.clientWidth || 800;
    const ch = canvas.clientHeight || 500;
    const prev = player;
    player = {
      x: cw * 0.25, y: ch * 0.5,
      vx: 0, vy: 0,
      r: 16,
      hp: prev ? prev.maxHp : 100,
      maxHp: prev ? prev.maxHp : 100,
      speed: prev ? prev.speed : 2.2,
      dmg: prev ? prev.dmg : 6,
      facing: 1,
      invuln: 0,
      punchT: 0,
      kickT: 0,
      dmgBoost: 0,
      speedBoost: 0,
    };

    enemies = [];
    obstacles = [];
    powerups = [];
    particles = [];

    syncShopButtons();
    // spawn first enemies
    for (let i = 0; i < Math.min(2, state.levelKillTarget); i++) spawnEnemy();
  }

  function endLevel(won) {
    state.playing = false;
    if (won) state.levelComplete = true;
    else state.gameOver = true;
    syncShopButtons();
  }

  function nextLevel() {
    if (state.level < MAX_LEVEL) {
      state.level += 1;
      startLevel();
    }
  }

  function retryLevel() {
    startLevel();
  }

  function resetGame() {
    // Full reset: level 1, but POINTS and ability purchases are kept (points never reset)
    state.level = 1;
    state.gameOver = false;
    state.levelComplete = false;
    state.playing = false;
    state.killsThisLevel = 0;
    state.levelKillTarget = 0;
    state.spawnTimer = 0;
    state.powerTimer = 0;
    state.messageTimer = 0;
    state.message = "";

    player = {
      x: 200, y: 240,
      vx: 0, vy: 0,
      r: 16,
      hp: 100,
      maxHp: 100,
      speed: 2.2,
      dmg: 6,
      facing: 1,
      invuln: 0,
      punchT: 0,
      kickT: 0,
      dmgBoost: 0,
      speedBoost: 0,
    };

    enemies = [];
    obstacles = [];
    powerups = [];
    particles = [];

    syncShopButtons();
  }

  // ---------- Shop ----------
  function canAfford(cost) { return state.points >= cost; }

  function buy(cost, onBuy) {
    if (state.playing) return; // shop only when between levels
    if (!canAfford(cost)) { ping("Not enough points."); return; }
    state.points -= cost;
    onBuy();
    elPoints.textContent = String(state.points);
    ping("Purchased!");
    syncShopButtons();
  }

  function syncShopButtons() {
    const bDash = document.getElementById('buyDash');
    const bTree = document.getElementById('buyTree');
    const bShield = document.getElementById('buyShield');
    const bHP = document.getElementById('buyHP');
    const bDmg = document.getElementById('buyDmg');
    const bSpd = document.getElementById('buySpd');
    if (!bDash) return;

    const shopOpen = !state.playing;
    bDash.textContent = abilities.dash.owned ? "Owned" : "Buy Dash (25)";
    bTree.textContent = abilities.tree.owned ? "Owned" : "Buy Tree (35)";
    bShield.textContent = abilities.shield.owned ? "Owned" : "Buy Shield (45)";

    bDash.disabled = !shopOpen || abilities.dash.owned || !canAfford(25);
    bTree.disabled = !shopOpen || abilities.tree.owned || !canAfford(35);
    bShield.disabled = !shopOpen || abilities.shield.owned || !canAfford(45);
    bHP.disabled = !shopOpen || !canAfford(30);
    bDmg.disabled = !shopOpen || !canAfford(30);
    bSpd.disabled = !shopOpen || !canAfford(30);
  }

  function setupShop() {
    const buyDashBtn = document.getElementById('buyDash');
    const buyTreeBtn = document.getElementById('buyTree');
    const buyShieldBtn = document.getElementById('buyShield');
    const buyHPBtn = document.getElementById('buyHP');
    const buyDmgBtn = document.getElementById('buyDmg');
    const buySpdBtn = document.getElementById('buySpd');
    if (buyDashBtn) buyDashBtn.onclick = () => buy(25, () => { abilities.dash.owned = true; });
    if (buyTreeBtn) buyTreeBtn.onclick = () => buy(35, () => { abilities.tree.owned = true; });
    if (buyShieldBtn) buyShieldBtn.onclick = () => buy(45, () => { abilities.shield.owned = true; });
    if (buyHPBtn) buyHPBtn.onclick = () => buy(30, () => { if (player) { player.maxHp += 20; player.hp += 20; } });
    if (buyDmgBtn) buyDmgBtn.onclick = () => buy(30, () => { if (player) player.dmg += 2; });
    if (buySpdBtn) buySpdBtn.onclick = () => buy(30, () => { if (player) player.speed += 0.2; });
  }

  // ---------- Messaging ----------
  function ping(msg) {
    state.message = msg;
    state.messageTimer = 1.2;
  }

  // ---------- Spawning ----------
  // Melee-only NPCs; combo length and speed scale with level (1 = single punch, 50 = 4-hit combos)
  function spawnEnemy() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const side = Math.floor(Math.random()*4);
    let x, y;
    if (side === 0) { x = -30; y = Math.random()*h; }
    if (side === 1) { x = w+30; y = Math.random()*h; }
    if (side === 2) { x = Math.random()*w; y = -30; }
    if (side === 3) { x = Math.random()*w; y = h+30; }

    const lvl = state.level;
    const hpBase = Math.floor(20 + lvl * 4);
    const speedBase = 1.0 + Math.min(1.8, lvl * 0.04);
    const dmgBase = 4 + Math.min(14, lvl * 0.35);
    // Combo: 1 = single punch only; 50 = up to 4-hit punch/kick combos
    const comboLen = Math.min(4, 1 + Math.floor(lvl / 15));
    const combo = [];
    for (let i = 0; i < comboLen; i++) {
      combo.push(Math.random() < 0.5 ? "punch" : "kick");
    }
    // Attack cooldown: higher level = faster recovery (more advanced)
    const atkCdBase = Math.max(0.25, 0.7 - lvl * 0.008);

    enemies.push({
      x, y,
      vx: 0, vy: 0,
      r: 16,
      hp: hpBase,
      maxHp: hpBase,
      speed: speedBase,
      dmg: dmgBase,
      atkCd: 0,
      stun: 0,
      combo,
      comboIndex: 0,
      atkCdBase,
      attackT: 0,   // windup for current attack
      attackType: null, // "punch" | "kick"
    });
  }

  function spawnPowerup() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const kinds = ["heal", "dmg", "spd"];
    const kind = kinds[Math.floor(Math.random()*kinds.length)];
    powerups.push({
      x: 40 + Math.random()*(w-80),
      y: 40 + Math.random()*(h-80),
      r: 12,
      kind,
      t: 10, // seconds until despawn
    });
  }

  function spawnTree(px, py) {
    obstacles.push({
      kind: "tree",
      x: px - 18, y: py - 26,
      w: 36, h: 52,
      t: 6.0
    });
  }

  // ---------- Combat (melee only) ----------
  function doPunch() {
    player.punchT = 0.16;
  }

  function doKick() {
    player.kickT = 0.22; // slightly longer active window
  }

  function damageEntity(ent, amount) {
    ent.hp -= amount;
  }

  // ---------- Drawing stick figures ----------
  function drawStick(x, y, facing, scale, isPlayer, hp01) {
    // head
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y - 18*scale, 7*scale, 0, Math.PI*2);
    ctx.strokeStyle = isPlayer ? "rgba(180,220,255,0.95)" : "rgba(255,180,180,0.9)";
    ctx.stroke();

    // body + limbs
    ctx.strokeStyle = isPlayer ? "rgba(220,240,255,0.9)" : "rgba(255,210,210,0.85)";
    ctx.beginPath();
    // torso
    ctx.moveTo(x, y - 11*scale);
    ctx.lineTo(x, y + 12*scale);
    // arms
    ctx.moveTo(x, y - 3*scale);
    ctx.lineTo(x + 10*scale*facing, y + 2*scale);
    ctx.moveTo(x, y - 3*scale);
    ctx.lineTo(x - 9*scale*facing, y + 3*scale);
    // legs
    ctx.moveTo(x, y + 12*scale);
    ctx.lineTo(x + 8*scale*facing, y + 26*scale);
    ctx.moveTo(x, y + 12*scale);
    ctx.lineTo(x - 8*scale*facing, y + 26*scale);
    ctx.stroke();

    // tiny HP bar
    const w = 28*scale, h = 4*scale;
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(255,255,255,0.12)";
    ctx.fillRect(x - w/2, y - 36*scale, w, h);
    ctx.fillStyle = isPlayer ? "rgba(120,200,255,0.9)" : "rgba(255,110,110,0.9)";
    ctx.fillRect(x - w/2, y - 36*scale, w*clamp(hp01,0,1), h);
    ctx.globalAlpha = 1;
  }

  function drawTreeObstacle(o) {
    // trunk + canopy
    ctx.save();
    ctx.translate(o.x + o.w/2, o.y + o.h/2);
    ctx.globalAlpha = clamp(o.t/6, 0.25, 1);
    // trunk
    ctx.fillStyle = "rgba(180,140,90,0.85)";
    ctx.fillRect(-6, -6, 12, 26);
    // canopy
    ctx.beginPath();
    ctx.arc(0, -16, 18, 0, Math.PI*2);
    ctx.fillStyle = "rgba(140,220,160,0.8)";
    ctx.fill();
    ctx.restore();
  }

  function drawPowerup(p) {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.arc(0, 0, p.r, 0, Math.PI*2);
    let col = "rgba(180,220,255,0.85)";
    if (p.kind === "heal") col = "rgba(160,255,200,0.85)";
    if (p.kind === "dmg") col = "rgba(255,210,140,0.9)";
    if (p.kind === "spd") col = "rgba(200,180,255,0.85)";
    ctx.fillStyle = col;
    ctx.fill();

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.font = "12px ui-monospace, monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(p.kind === "heal" ? "+" : (p.kind === "dmg" ? "D" : "S"), 0, 1);
    ctx.restore();
  }

  function spawnHitParticles(x,y, n=10) {
    for (let i=0;i<n;i++) {
      particles.push({
        x, y,
        vx: (Math.random()*2-1)*90,
        vy: (Math.random()*2-1)*90,
        r: 2 + Math.random()*2,
        t: 0.4 + Math.random()*0.4
      });
    }
  }

  function drawParticles(dt) {
    for (let i=particles.length-1;i>=0;i--) {
      const p = particles[i];
      p.t -= dt;
      if (p.t <= 0) { particles.splice(i,1); continue; }
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx *= 0.92; p.vy *= 0.92;
      ctx.globalAlpha = clamp(p.t, 0, 1);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // ---------- Game Logic ----------
  function update(dt) {
    state.messageTimer = Math.max(0, state.messageTimer - dt);
    elPoints.textContent = String(state.points);
    elWave.textContent = String(state.level);
    elKills.textContent = String(state.killsThisLevel);
    if (state.levelKillTarget > 0) {
      xpBar.style.width = (100 * Math.min(1, state.killsThisLevel / state.levelKillTarget)).toFixed(1) + "%";
    }

    if (!state.playing) {
      syncShopButtons();
      return;
    }

    // cooldown timers
    player.invuln = Math.max(0, player.invuln - dt);
    player.punchT = Math.max(0, player.punchT - dt);
    player.kickT = Math.max(0, player.kickT - dt);
    player.dmgBoost = Math.max(0, player.dmgBoost - dt);
    player.speedBoost = Math.max(0, player.speedBoost - dt);

    for (const k in abilities) abilities[k].t = Math.max(0, abilities[k].t - dt);
    abilities.shield.active = Math.max(0, abilities.shield.active - dt);

    // movement
    let ax = 0, ay = 0;
    if (keys.has('a')) ax -= 1;
    if (keys.has('d')) ax += 1;
    if (keys.has('w')) ay -= 1;
    if (keys.has('s')) ay += 1;
    const len = Math.hypot(ax, ay) || 1;
    ax /= len; ay /= len;

    const speed = player.speed * (player.speedBoost > 0 ? 1.35 : 1);
    player.vx = ax * speed;
    player.vy = ay * speed;

    if (ax !== 0) player.facing = ax > 0 ? 1 : -1;

    // melee input: punch (Space), kick (K)
    if (keys.has(' ') && player.punchT <= 0 && player.kickT <= 0) doPunch();
    if (keys.has('k') && player.punchT <= 0 && player.kickT <= 0) doKick();

    if (keys.has('f') && abilities.dash.owned && abilities.dash.t <= 0) {
      abilities.dash.t = abilities.dash.cd;
      const dashMag = 12;
      const dx = (ax !== 0 || ay !== 0) ? ax : player.facing;
      const dy = (ax !== 0 || ay !== 0) ? ay : 0;
      player.x += dx * dashMag * 6;
      player.y += dy * dashMag * 6;
      player.invuln = Math.max(player.invuln, 0.15);
      spawnHitParticles(player.x, player.y, 12);
    }

    if (keys.has('r') && abilities.tree.owned && abilities.tree.t <= 0) {
      abilities.tree.t = abilities.tree.cd;
      spawnTree(player.x + player.facing*26, player.y + 10);
      ping("Tree!");
    }

    if (keys.has('e') && abilities.shield.owned && abilities.shield.t <= 0) {
      abilities.shield.t = abilities.shield.cd;
      abilities.shield.active = 3.0;
      ping("Shield up!");
    }

    // apply movement, bounds
    player.x += player.vx;
    player.y += player.vy;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    player.x = clamp(player.x, 20, w-20);
    player.y = clamp(player.y, 50, h-20);

    // obstacles timer + collision (simple push out)
    for (let i=obstacles.length-1;i>=0;i--) {
      const o = obstacles[i];
      o.t -= dt;
      if (o.t <= 0) { obstacles.splice(i,1); continue; }

      // player collision
      const pb = { x: player.x-player.r, y: player.y-player.r, w: player.r*2, h: player.r*2 };
      if (rectsOverlap(pb, o)) {
        // push player out (very simple)
        if (player.x < o.x) player.x = o.x - player.r - 1;
        else if (player.x > o.x + o.w) player.x = o.x + o.w + player.r + 1;
        if (player.y < o.y) player.y = o.y - player.r - 1;
        else if (player.y > o.y + o.h) player.y = o.y + o.h + player.r + 1;
      }
    }

    // Punch hits enemies
    const baseDmg = player.dmg + (player.dmgBoost > 0 ? 3 : 0);
    if (player.punchT > 0) {
      const punchRange = 34;
      const px = player.x + player.facing * 22;
      const py = player.y + 5;
      for (const e of enemies) {
        if (dist2(px, py, e.x, e.y) < (punchRange * punchRange)) {
          damageEntity(e, baseDmg * dt * 8.0);
          e.stun = Math.max(e.stun, 0.08);
          spawnHitParticles(e.x, e.y, 2);
        }
      }
    }
    // Kick hits enemies (slightly longer range, more damage)
    if (player.kickT > 0) {
      const kickRange = 40;
      const kx = player.x + player.facing * 28;
      const ky = player.y + 14;
      for (const e of enemies) {
        if (dist2(kx, ky, e.x, e.y) < (kickRange * kickRange)) {
          damageEntity(e, (baseDmg + 2) * dt * 7.0);
          e.stun = Math.max(e.stun, 0.12);
          spawnHitParticles(e.x, e.y, 4);
        }
      }
    }

    // Enemy AI: melee only, combo punch/kick by level
    for (const e of enemies) {
      e.stun = Math.max(0, e.stun - dt);
      e.atkCd = Math.max(0, e.atkCd - dt);
      e.attackT = Math.max(0, e.attackT - dt);

      const dx = player.x - e.x, dy = player.y - e.y;
      const d = Math.hypot(dx, dy) || 1;
      const facing = (player.x - e.x) >= 0 ? 1 : -1;

      if (e.stun <= 0) {
        let steerX = dx / d, steerY = dy / d;
        for (const o of obstacles) {
          const eb = { x: e.x - e.r, y: e.y - e.r, w: e.r * 2, h: e.r * 2 };
          if (rectsOverlap(eb, o)) {
            const cx = o.x + o.w / 2, cy = o.y + o.h / 2;
            const odx = e.x - cx, ody = e.y - cy;
            const ol = Math.hypot(odx, ody) || 1;
            steerX += (odx / ol) * 1.4;
            steerY += (ody / ol) * 1.4;
          }
        }
        const sl = Math.hypot(steerX, steerY) || 1;
        steerX /= sl; steerY /= sl;
        e.vx = steerX * e.speed;
        e.vy = steerY * e.speed;
      } else {
        e.vx *= 0.7; e.vy *= 0.7;
      }

      e.x += e.vx;
      e.y += e.vy;

      // Melee attack: start next in combo when in range and atkCd ready
      if (e.attackT <= 0 && e.atkCd <= 0 && d < 38) {
        e.attackType = e.combo[e.comboIndex];
        e.attackT = 0.08 + (e.combo.length > 1 ? 0.02 : 0); // windup
      }
      // Deal damage once when windup ends
      if (e.attackType && e.attackT <= 0 && d < 42) {
        let dmg = e.attackType === "kick" ? e.dmg * 1.2 : e.dmg;
        if (abilities.shield.active > 0) dmg *= 0.55;
        if (player.invuln <= 0) {
          player.hp -= dmg;
          player.invuln = 0.12;
          spawnHitParticles(player.x, player.y, 10);
        }
        e.comboIndex = (e.comboIndex + 1) % e.combo.length;
        e.atkCd = e.atkCdBase;
        e.attackType = null;
      }

      e.x = clamp(e.x, -40, w + 40);
      e.y = clamp(e.y, -40, h + 40);
    }

    // powerups update + pickup
    for (let i=powerups.length-1;i>=0;i--) {
      const p = powerups[i];
      p.t -= dt;
      if (p.t <= 0) { powerups.splice(i,1); continue; }
      if (dist2(p.x, p.y, player.x, player.y) < (26*26)) {
        if (p.kind === "heal") {
          player.hp = Math.min(player.maxHp, player.hp + 30);
          ping("Healed!");
        } else if (p.kind === "dmg") {
          player.dmgBoost = 8.0;
          ping("Damage Up!");
        } else if (p.kind === "spd") {
          player.speedBoost = 8.0;
          ping("Speed Up!");
        }
        powerups.splice(i,1);
      }
    }

    // enemies death -> points (points never reset)
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      if (e.hp <= 0) {
        enemies.splice(i, 1);
        state.killsThisLevel += 1;
        const gain = 5 + Math.floor(state.level * 1.2);
        state.points += gain;
        spawnHitParticles(e.x, e.y, 22);
        if (state.killsThisLevel >= state.levelKillTarget) {
          endLevel(true);
          ping("Level " + state.level + " complete!");
        }
      }
    }

    // spawn enemies during level (until we have enough on screen)
    const targetEnemies = 2 + Math.floor(state.level * 0.6);
    state.spawnTimer -= dt;
    if (state.playing && enemies.length < targetEnemies && state.spawnTimer <= 0) {
      state.spawnTimer = Math.max(0.3, 0.9 - state.level * 0.01);
      spawnEnemy();
      if (state.level >= 15 && Math.random() < 0.2) spawnEnemy();
    }

    // spawn powerups
    state.powerTimer -= dt;
    if (state.powerTimer <= 0) {
      state.powerTimer = 6.5 + Math.random()*3.5;
      if (powerups.length < 2) spawnPowerup();
    }

    // lose condition (points kept; shop opens)
    if (player.hp <= 0) {
      endLevel(false);
      ping("You died â€” buy upgrades, then press Enter to retry");
    }

    hpBar.style.width = (100 * clamp(player.hp / player.maxHp, 0, 1)).toFixed(1) + "%";
    syncShopButtons();
  }

  // ---------- Render ----------
  function render(dt) {
    const w = canvas.clientWidth, h = canvas.clientHeight;

    // subtle ground
    ctx.clearRect(0,0,w,h);
    ctx.globalAlpha = 1;

    // vignette-ish overlays
    ctx.fillStyle = "rgba(0,0,0,0.20)";
    ctx.fillRect(0,0,w,h);

    // obstacles
    for (const o of obstacles) {
      if (o.kind === "tree") drawTreeObstacle(o);
    }

    // powerups
    for (const p of powerups) drawPowerup(p);

    // enemies
    for (const e of enemies) {
      const facing = (player.x - e.x) >= 0 ? 1 : -1;
      drawStick(e.x, e.y, facing, 1, false, e.hp / e.maxHp);
    }

    // player (with shield ring)
    drawStick(player.x, player.y, player.facing, 1, true, player.hp / player.maxHp);

    if (abilities.shield.active > 0) {
      ctx.save();
      ctx.globalAlpha = 0.25 + 0.2*Math.sin(performance.now()/120);
      ctx.beginPath();
      ctx.arc(player.x, player.y, 26, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(140,210,255,0.9)";
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();
    }

    // punch / kick arc indicator
    if (player.punchT > 0) {
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      ctx.arc(player.x + player.facing*18, player.y+4, 18, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(220,240,255,0.9)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }
    if (player.kickT > 0) {
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.arc(player.x + player.facing*26, player.y+14, 16, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,200,120,0.9)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    // particles
    drawParticles(dt);

    // HUD overlay (canvas)
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "12px ui-monospace, monospace";
    ctx.textBaseline = "top";
    ctx.fillText("FPS: " + Math.round(1/Math.max(0.0001,dt)), 10, 10);

    // cooldowns
    const cdLines = [];
    if (abilities.dash.owned) cdLines.push(`F Dash: ${abilities.dash.t.toFixed(1)}s`);
    if (abilities.tree.owned) cdLines.push(`R Tree: ${abilities.tree.t.toFixed(1)}s`);
    if (abilities.shield.owned) cdLines.push(`E Shield: ${abilities.shield.t.toFixed(1)}s`);
    if (cdLines.length) {
      ctx.globalAlpha = 0.85;
      ctx.fillText(cdLines.join("  |  "), 10, 28);
    }

    // message
    if (state.messageTimer > 0) {
      ctx.globalAlpha = clamp(state.messageTimer/1.2, 0, 1);
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(10, 52, Math.min(520, 14 + ctx.measureText(state.message).width), 26);
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.fillText(state.message, 18, 58);
    }

    // between-levels overlay: died or level complete
    if (state.levelComplete) {
      ctx.globalAlpha = 0.88;
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(0,0,w,h);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(166,255,203,0.95)";
      ctx.font = "26px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("LEVEL " + state.level + " COMPLETE!", w/2, h/2 - 36);
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillText(state.level >= MAX_LEVEL ? "Max level reached. Press Enter to play again." : "Buy upgrades, then Press Enter for next level", w/2, h/2 + 4);
      ctx.textAlign = "left";
    } else if (state.gameOver) {
      ctx.globalAlpha = 0.88;
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(0,0,w,h);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(255,180,180,0.95)";
      ctx.font = "26px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("YOU DIED", w/2, h/2 - 36);
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillText("Buy upgrades, then Press Enter to retry level", w/2, h/2 + 4);
      ctx.textAlign = "left";
    } else if (!state.playing && state.killsThisLevel === 0) {
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = "rgba(0,0,0,0.4)";
      ctx.fillRect(0,0,w,h);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "18px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Level " + state.level + " / " + MAX_LEVEL, w/2, h/2 - 20);
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillStyle = "rgba(232,238,252,0.85)";
      ctx.fillText("Press Enter to start", w/2, h/2 + 10);
      ctx.textAlign = "left";
    }

    ctx.restore();
  }

  // ---------- Main Loop ----------
  function loop(t) {
    const now = t * 0.001;
    const dt = clamp(now - state.lastTime, 0, 0.033);
    state.lastTime = now;

    update(dt);
    render(dt);

    requestAnimationFrame(loop);
  }

  // ---------- Boot ----------
  resize();
  resetGame();
  setupShop();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
