<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1">
  <title>Arcade Toilet Target</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; touch-action: none; -webkit-tap-highlight-color: transparent; }
    #gameCanvas { display: block; width: 100%; height: 100%; background: #1a5f7a; }
    #ui { position: fixed; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 10; }
    #ui > * { pointer-events: auto; }
    #score { position: absolute; top: 12px; left: 12px; font: bold 24px/1 sans-serif; color: #fff; text-shadow: 0 1px 3px #000; }
    #timer { position: absolute; top: 12px; right: 12px; font: bold 24px/1 sans-serif; color: #ffeb3b; text-shadow: 0 1px 3px #000; }
    #combo { position: absolute; top: 12px; left: 50%; transform: translateX(-50%); font: bold 20px/1 sans-serif; color: #ff9800; text-shadow: 0 1px 3px #000; }
    #startBtn { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 18px 36px; min-height: 48px; min-width: 200px; font: bold 20px sans-serif; background: #4caf50; color: #fff; border: none; border-radius: 12px; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.3); -webkit-user-select: none; user-select: none; }
    #startBtn:active { transform: translate(-50%, -50%) scale(0.98); }
    #gameOver { position: absolute; left: 50%; top: 45%; transform: translate(-50%, -50%); text-align: center; display: none; }
    #gameOver.show { display: block; }
    #finalScore { font: bold 28px sans-serif; color: #fff; text-shadow: 0 2px 4px #000; margin-bottom: 12px; }
    #restartBtn { padding: 14px 28px; font: bold 18px sans-serif; background: #2196f3; color: #fff; border: none; border-radius: 10px; cursor: pointer; }
    #instructions { position: absolute; left: 50%; transform: translateX(-50%); top: 58%; width: 90%; max-width: 340px; text-align: center; font: 14px/1.4 sans-serif; color: rgba(255,255,255,0.95); text-shadow: 0 1px 2px #000; pointer-events: none; }
    #instructions.hidden { display: none; }
    #instructions strong { color: #ffeb3b; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="ui">
    <div id="score">Score: 0</div>
    <div id="timer">30</div>
    <div id="combo"></div>
    <button id="startBtn">Start (Allow Motion)</button>
    <div id="instructions">
      <div id="instructionsMobile" style="display: none;">
        <strong>How to play</strong><br>
        Tilt phone left/right to aim; more tilt = longer stream.<br>
        Tap screen to fire.<br>
        Hit balls (+10), baby (+15), plane (+25). Avoid duck (−10). Golden duck = +100.
      </div>
      <div id="instructionsDesktop" style="display: none;">
        <strong>How to play</strong><br>
        Mouse left/right to aim; distance from center = stream length (or A/D aim, W/S length).<br>
        Click (or hold) to fire.<br>
        Hit balls (+10), baby (+15), plane (+25). Avoid duck (−10). Golden duck = +100.
      </div>
    </div>
    <div id="gameOver">
      <div id="finalScore">Score: 0</div>
      <button id="restartBtn">Play Again</button>
    </div>
  </div>

  <script>
(function() {
  'use strict';

  // ========== CANVAS & CONTEXT ==========
  // Fullscreen canvas for 60fps rendering; no external libraries.
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let W, H;

  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // ========== IMAGE ASSETS ==========
  var imgBaby = new Image();
  var imgDuck = new Image();
  var imgPlane = new Image();
  imgBaby.src = 'baby.png';
  imgDuck.src = 'duck.png';
  imgPlane.src = 'plane.png';

  // ========== GAME STATE ==========
  let state = 'idle'; // idle | playing | gameOver
  let score = 0;
  let timeLeft = 30;
  let lastTime = 0;
  let comboCount = 0;
  let comboMultiplier = 1;
  let aimAngle = -Math.PI / 2;
  let streamPower = 1;
  let firing = false;
  let streamParticles = [];
  let targets = [];
  let duck = null;
  let goldenDuck = null;
  let baby = null;
  let plane = null;
  let babyRespawnAt = 0;
  let planeSpawnAccum = 0;
  let screenShake = 0;
  let splitStreamUntil = 0;
  const SPLIT_STREAM_OFFSET = 0.22;
  const SPLIT_STREAM_DURATION = 4000;
  let windUntil = 0;
  let windForce = 0;
  let shrinkFactor = 1;
  let comboPopups = [];
  let backgroundBubbles = [];
  let spawnAccum = 0;
  let duckSpawnAccum = 0;
  let goldenDuckSpawnAccum = 0;
  let timerInterval = null;
  let motionPermissionGranted = false;

  // ========== IOS DEVICE ORIENTATION PERMISSION ==========
  // Required for iOS 13+: requestPermission must be called from a user gesture (Start button).
  // Wrapped in try-catch; timeout ensures game starts even if permission dialog hangs.
  function requestMotionPermission(cb) {
    var done = false;
    function finish(granted) {
      if (done) return;
      done = true;
      motionPermissionGranted = granted;
      if (cb) cb(granted);
    }
    setTimeout(function() { finish(false); }, 4000);
    try {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(function(permission) {
            finish(permission === 'granted');
          })
          .catch(function() { finish(false); });
      } else {
        finish(true);
      }
    } catch (e) {
      finish(false);
    }
  }

  // ========== SPLIT STREAM POWERUP ==========
  // Hit with stream to add two extra streams (left/right) for a short time. Stacks each time you hit it.
  let splitStreamPickup = null;
  function trySpawnSplitStreamPickup() {
    if (splitStreamPickup || splitStreamUntil > Date.now()) return;
    if (Math.random() > 0.008) return;
    splitStreamPickup = {
      x: 30 + Math.random() * (W - 60),
      y: H * 0.3 + Math.random() * H * 0.3,
      r: 18
    };
  }
  function updateSplitStreamPickup(dt) {
    if (!splitStreamPickup || !firing) return;
    var points = getAllStreamPoints();
    for (var i = 0; i < points.length; i++) {
      if (hitTestCircle(points[i].x, points[i].y, splitStreamPickup.x, splitStreamPickup.y, splitStreamPickup.r)) {
        splitStreamUntil = Date.now() + SPLIT_STREAM_DURATION;
        splitStreamPickup = null;
        soundGolden();
        break;
      }
    }
  }
  function drawSplitStreamPickup() {
    if (!splitStreamPickup) return;
    ctx.fillStyle = 'rgba(255,193,7,0.9)';
    ctx.beginPath();
    ctx.arc(splitStreamPickup.x, splitStreamPickup.y, splitStreamPickup.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Split Stream!', splitStreamPickup.x, splitStreamPickup.y + 5);
    ctx.textAlign = 'left';
  }

  // ========== PLAYER (BOTTOM CENTER) ==========
  const player = { x: 0, y: 0, baseY: 0, nozzleWidth: 12 };

  function updatePlayerPosition() {
    player.x = W / 2;
    player.baseY = H - 40;
    player.y = player.baseY;
  }

  // --- STREAM PHYSICS (CURVED, GRAVITY) ---
  // Light gravity + high speed + many segments so stream can reach the top of the screen.
  const GRAVITY = 0.12;
  const STREAM_SPEED = 26;
  const SEGMENT_DIST = 8;
  const MAX_SEGMENTS = 90;

  function getStreamSpeed() {
    return STREAM_SPEED * streamPower;
  }

  function getStreamSegments() {
    return Math.max(45, Math.floor(MAX_SEGMENTS * streamPower));
  }

  function getStreamPointsWithAngle(angle) {
    const speed = getStreamSpeed();
    const maxSeg = getStreamSegments();
    const points = [];
    let x = player.x;
    let y = player.y;
    let vx = Math.cos(angle) * speed;
    let vy = Math.sin(angle) * speed;
    points.push({ x, y });
    for (let i = 0; i < maxSeg; i++) {
      vy += GRAVITY;
      vx += windForce * 0.02;
      x += vx;
      y += vy;
      points.push({ x, y });
    }
    return points;
  }

  function getStreamPoints() {
    return getStreamPointsWithAngle(aimAngle);
  }

  function getAllStreamPoints() {
    var main = getStreamPointsWithAngle(aimAngle);
    if (splitStreamUntil <= Date.now()) return main;
    var left = getStreamPointsWithAngle(aimAngle - SPLIT_STREAM_OFFSET);
    var right = getStreamPointsWithAngle(aimAngle + SPLIT_STREAM_OFFSET);
    return main.concat(left).concat(right);
  }

  // ========== TARGETS (FLOATING BALLS) ==========
  // Balls bounce off edges; +10 hit, -5 miss; radius can shrink over time (difficulty).
  const TARGET_BASE_R = 20;
  const TARGET_MIN_R = 8;
  const MAX_TARGETS = 12;

  function spawnTarget() {
    if (targets.length >= MAX_TARGETS) return;
    const r = Math.max(TARGET_MIN_R, TARGET_BASE_R * shrinkFactor);
    targets.push({
      x: r + Math.random() * (W - 2 * r),
      y: r + Math.random() * (H * 0.5 - 2 * r),
      r,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      isGolden: false
    });
  }

  function hitTestCircle(ax, ay, cx, cy, cr) {
    return (ax - cx) ** 2 + (ay - cy) ** 2 <= cr * cr;
  }

  function hitTestRect(ax, ay, rx, ry, rw, rh) {
    return ax >= rx && ax <= rx + rw && ay >= ry && ay <= ry + rh;
  }

  // --- DUCK (OBSTACLE) ---
  const DUCK_W = 50;
  const DUCK_H = 35;

  const BABY_W = 44;
  const BABY_H = 50;
  const BABY_POINTS = 15;

  const PLANE_W = 60;
  const PLANE_H = 32;
  const PLANE_POINTS = 25;

  function spawnDuck() {
    if (duck && !duck.flyingAway) return;
    const fromLeft = Math.random() > 0.5;
    duck = {
      x: fromLeft ? -DUCK_W - 20 : W + 20,
      y: H * 0.25 + Math.random() * H * 0.25,
      w: DUCK_W,
      h: DUCK_H,
      vx: fromLeft ? 5 : -5,
      flyingAway: false,
      isGolden: false
    };
  }

  function spawnGoldenDuck() {
    if (goldenDuck) return;
    const fromLeft = Math.random() > 0.5;
    goldenDuck = {
      x: fromLeft ? -DUCK_W - 20 : W + 20,
      y: H * 0.2 + Math.random() * H * 0.2,
      w: DUCK_W,
      h: DUCK_H,
      vx: fromLeft ? 4 : -4,
      flyingAway: false
    };
  }

  function spawnBaby() {
    if (baby || Date.now() < babyRespawnAt) return;
    baby = {
      x: BABY_W + Math.random() * (W - 2 * BABY_W),
      y: BABY_H + Math.random() * (H * 0.45 - 2 * BABY_H),
      w: BABY_W,
      h: BABY_H,
      vx: (Math.random() - 0.5) * 3,
      vy: (Math.random() - 0.5) * 3
    };
  }

  function spawnPlane() {
    if (plane) return;
    var fromLeft = Math.random() > 0.5;
    plane = {
      x: fromLeft ? -PLANE_W - 30 : W + 30,
      y: H * 0.15 + Math.random() * H * 0.2,
      w: PLANE_W,
      h: PLANE_H,
      vx: fromLeft ? 6 : -6
    };
  }

  // ========== AUDIO (SIMPLE WEB AUDIO) ==========
  // No external assets; oscillators for hit, miss, quack, splash, golden.
  let audioCtx = null;

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  function playTone(freq, duration, type) {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.type = type || 'sine';
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + duration);
  }

  function soundHit() {
    playTone(600, 0.08, 'square');
    setTimeout(function() { playTone(800, 0.06, 'square'); }, 50);
  }

  function soundMiss() {
    playTone(200, 0.15, 'sawtooth');
  }

  function soundQuack() {
    playTone(400, 0.1, 'sawtooth');
    setTimeout(function() { playTone(350, 0.12, 'sawtooth'); }, 80);
  }

  function soundSplash() {
    playTone(150, 0.2, 'triangle');
    playTone(100, 0.15, 'sine');
  }

  function soundGolden() {
    playTone(880, 0.1, 'sine');
    playTone(1320, 0.12, 'sine');
  }

  // --- VIBRATION ---
  function vibrateHit() {
    if (navigator.vibrate) navigator.vibrate(30);
  }

  function vibrateDuck() {
    if (navigator.vibrate) navigator.vibrate([40, 30, 40]);
  }

  // ========== PARTICLE HELPERS ==========
  // Splash particles and combo popups (bonus).
  function addSplashParticles(x, y, count) {
    for (let i = 0; i < count; i++) {
      streamParticles.push({
        x, y,
        vx: (Math.random() - 0.5) * 8,
        vy: -Math.random() * 6 - 2,
        life: 0.5 + Math.random() * 0.4,
        maxLife: 1,
        r: 3 + Math.random() * 4
      });
    }
  }

  function addComboPopup(x, y, text) {
    comboPopups.push({ x, y, text, life: 1, vy: -1.5 });
  }

  // --- BACKGROUND BUBBLES ---
  function initBackgroundBubbles() {
    backgroundBubbles = [];
    for (let i = 0; i < 15; i++) {
      backgroundBubbles.push({
        x: Math.random() * W,
        y: Math.random() * H,
        r: 4 + Math.random() * 12,
        vy: -0.3 - Math.random() * 0.5,
        opacity: 0.2 + Math.random() * 0.2
      });
    }
  }

  function updateBackgroundBubbles(dt) {
    backgroundBubbles.forEach(function(b) {
      b.y += b.vy * dt * 0.06;
      if (b.y < -b.r) { b.y = H + b.r; b.x = Math.random() * W; }
    });
  }

  // ========== STREAM vs WORLD COLLISION ==========
  // Circle collision for balls and bowl; rectangle for duck. Order: duck, golden duck, balls, bowl.
  function checkStreamCollisions(points) {
    let hitSomething = false;
    for (let i = 1; i < points.length; i++) {
      const p = points[i];

      if (duck && !duck.flyingAway && hitTestRect(p.x, p.y, duck.x, duck.y, duck.w, duck.h)) {
        hitSomething = true;
        score = Math.max(0, score - 10);
        screenShake = 15;
        soundQuack();
        vibrateDuck();
        duck.flyingAway = true;
        duck.vx = duck.vx > 0 ? 12 : -12;
        duck.vy = -4;
        comboCount = 0;
        comboMultiplier = 1;
        break;
      }

      if (goldenDuck && !goldenDuck.flyingAway && hitTestRect(p.x, p.y, goldenDuck.x, goldenDuck.y, goldenDuck.w, goldenDuck.h)) {
        hitSomething = true;
        score += 100 * comboMultiplier;
        soundGolden();
        vibrateHit();
        addComboPopup(goldenDuck.x + goldenDuck.w / 2, goldenDuck.y, '+100');
        goldenDuck.flyingAway = true;
        goldenDuck.vx = goldenDuck.vx > 0 ? 14 : -14;
        goldenDuck.vy = -5;
        comboCount++;
        comboMultiplier = Math.min(5, 1 + Math.floor(comboCount / 2));
        break;
      }

      if (baby && hitTestRect(p.x, p.y, baby.x, baby.y, baby.w, baby.h)) {
        hitSomething = true;
        var pts = BABY_POINTS * comboMultiplier;
        score += pts;
        soundHit();
        vibrateHit();
        addSplashParticles(baby.x + baby.w / 2, baby.y + baby.h / 2, 8);
        addComboPopup(baby.x + baby.w / 2, baby.y, '+' + pts);
        baby = null;
        babyRespawnAt = Date.now() + 2000;
        comboCount++;
        comboMultiplier = Math.min(5, 1 + Math.floor(comboCount / 2));
        break;
      }

      if (plane && hitTestRect(p.x, p.y, plane.x, plane.y, plane.w, plane.h)) {
        hitSomething = true;
        var pts = PLANE_POINTS * comboMultiplier;
        score += pts;
        soundHit();
        vibrateHit();
        addSplashParticles(plane.x + plane.w / 2, plane.y + plane.h / 2, 10);
        addComboPopup(plane.x + plane.w / 2, plane.y, '+' + pts);
        plane = null;
        comboCount++;
        comboMultiplier = Math.min(5, 1 + Math.floor(comboCount / 2));
        break;
      }

      for (let t = targets.length - 1; t >= 0; t--) {
        const ball = targets[t];
        if (hitTestCircle(p.x, p.y, ball.x, ball.y, ball.r)) {
          hitSomething = true;
          score += 10 * comboMultiplier;
          soundHit();
          vibrateHit();
          addSplashParticles(ball.x, ball.y, 8);
          addComboPopup(ball.x, ball.y, '+' + (10 * comboMultiplier));
          targets.splice(t, 1);
          comboCount++;
          comboMultiplier = Math.min(5, 1 + Math.floor(comboCount / 2));
          break;
        }
      }
      if (hitSomething) break;

    }

    if (!hitSomething && points.length > 5) {
      const last = points[points.length - 1];
      if (last.y > H * 0.6) {
        addSplashParticles(last.x, last.y, 6);
        soundSplash();
        score = Math.max(0, score - 5);
        comboCount = 0;
        comboMultiplier = 1;
      }
    }
  }

  // --- INPUT ---
  let orientationHandler = null;

  var isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

  function bindOrientation() {
    orientationHandler = function(e) {
      if (state !== 'playing' || e.gamma == null) return;
      const g = Math.max(-90, Math.min(90, e.gamma));
      aimAngle = -Math.PI / 2 + (g / 90) * Math.PI * 0.95;
      var tiltAmount = Math.min(90, Math.abs(g));
      streamPower = 0.65 + (tiltAmount / 90) * 0.85;
    };
    window.addEventListener('deviceorientation', orientationHandler);
  }

  function unbindOrientation() {
    if (orientationHandler) window.removeEventListener('deviceorientation', orientationHandler);
    orientationHandler = null;
  }

  // Desktop: mouse controls aim and stream length; full range so stream can hit any target
  canvas.addEventListener('mousemove', function(e) {
    if (state !== 'playing' || isTouchDevice) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const centerX = rect.width / 2;
    const t = (x - centerX) / centerX;
    aimAngle = -Math.PI / 2 + Math.max(-1, Math.min(1, t)) * Math.PI * 0.95;
    var distFromCenter = Math.min(1, Math.abs(x - centerX) / centerX);
    streamPower = 0.65 + distFromCenter * 0.85;
  });
  window.addEventListener('keydown', function(e) {
    if (state !== 'playing' || isTouchDevice) return;
    if (e.key === 'a' || e.key === 'A') aimAngle = Math.max(-Math.PI - 0.1, aimAngle - 0.06);
    if (e.key === 'd' || e.key === 'D') aimAngle = Math.min(0.1, aimAngle + 0.06);
    if (e.key === 'w' || e.key === 'W') streamPower = Math.min(1.5, streamPower + 0.05);
    if (e.key === 's' || e.key === 'S') streamPower = Math.max(0.65, streamPower - 0.05);
  });

  canvas.addEventListener('touchstart', function(e) {
    e.preventDefault();
    if (state === 'playing') firing = true;
  });
  canvas.addEventListener('touchend', function(e) {
    e.preventDefault();
    firing = false;
  });
  canvas.addEventListener('mousedown', function() { if (state === 'playing') firing = true; });
  canvas.addEventListener('mouseup', function() { firing = false; });
  canvas.addEventListener('mouseleave', function() { firing = false; });

  // ========== GAME LOOP ==========
  // requestAnimationFrame at 60fps; update then draw.
  function update(dt) {
    if (state !== 'playing') return;

    updatePlayerPosition();
    updateBackgroundBubbles(dt);

    if (screenShake > 0) screenShake -= dt * 0.2;
    if (screenShake < 0) screenShake = 0;

    if (splitStreamUntil > 0 && splitStreamUntil < Date.now()) splitStreamUntil = 0;
    if (windUntil > 0 && windUntil < Date.now()) { windUntil = 0; windForce = 0; }

    shrinkFactor = Math.max(0.4, 1 - (30 - timeLeft) / 30 * 0.6);

    if (firing) {
      var points = getAllStreamPoints();
      checkStreamCollisions(points);
    }

    for (let i = 0; i < targets.length; i++) {
      const t = targets[i];
      t.x += t.vx;
      t.y += t.vy;
      if (t.x <= t.r || t.x >= W - t.r) t.vx *= -1;
      if (t.y <= t.r || t.y >= H - t.r) t.vy *= -1;
    }

    if (duck) {
      if (duck.flyingAway) {
        duck.vy += 0.3;
        duck.x += duck.vx;
        duck.y += duck.vy;
        if (duck.y > H + 50 || duck.x < -100 || duck.x > W + 100) duck = null;
      } else {
        duck.x += duck.vx;
        if (duck.x < -DUCK_W - 50 || duck.x > W + 50) duck = null;
      }
    }

    if (goldenDuck) {
      if (goldenDuck.flyingAway) {
        goldenDuck.vy += 0.25;
        goldenDuck.x += goldenDuck.vx;
        goldenDuck.y += goldenDuck.vy;
        if (goldenDuck.y > H + 50 || goldenDuck.x < -100 || goldenDuck.x > W + 100) goldenDuck = null;
      } else {
        goldenDuck.x += goldenDuck.vx;
        if (goldenDuck.x < -DUCK_W - 50 || goldenDuck.x > W + 50) goldenDuck = null;
      }
    }

    if (baby) {
      baby.x += baby.vx;
      baby.y += baby.vy;
      if (baby.x <= 0 || baby.x >= W - baby.w) baby.vx *= -1;
      if (baby.y <= 0 || baby.y >= H - baby.h) baby.vy *= -1;
    }

    if (plane) {
      plane.x += plane.vx;
      if (plane.x < -PLANE_W - 80 || plane.x > W + 80) plane = null;
    }

    for (let i = streamParticles.length - 1; i >= 0; i--) {
      const p = streamParticles[i];
      p.x += p.vx * dt * 0.06;
      p.y += p.vy * dt * 0.06;
      p.vy += 0.15 * dt * 0.06;
      p.life -= dt * 0.008;
      if (p.life <= 0) streamParticles.splice(i, 1);
    }

    for (let i = comboPopups.length - 1; i >= 0; i--) {
      const c = comboPopups[i];
      c.y += c.vy * dt * 0.06;
      c.life -= dt * 0.012;
      if (c.life <= 0) comboPopups.splice(i, 1);
    }

    trySpawnSplitStreamPickup();
    updateSplitStreamPickup(dt);

    // Spawn one ball roughly every 2s at start, every ~1.2s as timer runs down (dt in ms).
    spawnAccum += dt / (2200 - (30 - timeLeft) * 35);
    while (spawnAccum > 1) {
      spawnAccum -= 1;
      spawnTarget();
    }

    duckSpawnAccum += dt * 0.08;
    if (duckSpawnAccum > 1 && !duck) {
      duckSpawnAccum = 0;
      spawnDuck();
    }

    goldenDuckSpawnAccum += dt * 0.015;
    if (goldenDuckSpawnAccum > 1 && !goldenDuck) {
      goldenDuckSpawnAccum = 0;
      spawnGoldenDuck();
    }

    spawnBaby();
    planeSpawnAccum += dt * 0.04;
    if (planeSpawnAccum > 1 && !plane) {
      planeSpawnAccum = 0;
      spawnPlane();
    }

    if (Math.random() < 0.001 && windUntil < Date.now()) {
      windUntil = Date.now() + 3000;
      windForce = (Math.random() - 0.5) * 8;
    }
  }

  function draw() {
    let dx = 0, dy = 0;
    if (screenShake > 0) {
      dx = (Math.random() - 0.5) * screenShake;
      dy = (Math.random() - 0.5) * screenShake;
    }
    ctx.save();
    ctx.translate(dx, dy);

    ctx.fillStyle = '#1a5f7a';
    ctx.fillRect(0, 0, W, H);

    backgroundBubbles.forEach(function(b) {
      ctx.fillStyle = 'rgba(255,255,255,' + b.opacity + ')';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    });

    targets.forEach(function(t) {
      ctx.fillStyle = t.isGolden ? '#ffd700' : '#ff5722';
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
    });

    if (duck && !duck.flyingAway) {
      if (imgDuck.complete && imgDuck.naturalWidth) {
        ctx.drawImage(imgDuck, duck.x, duck.y, duck.w, duck.h);
      } else {
        ctx.fillStyle = '#ff9800';
        ctx.fillRect(duck.x, duck.y, duck.w, duck.h);
        ctx.fillStyle = '#000';
        ctx.font = '14px sans-serif';
        ctx.fillText('QUACK', duck.x + 8, duck.y + 22);
      }
    }

    if (goldenDuck && !goldenDuck.flyingAway) {
      if (imgDuck.complete && imgDuck.naturalWidth) {
        ctx.globalAlpha = 0.95;
        ctx.drawImage(imgDuck, goldenDuck.x, goldenDuck.y, goldenDuck.w, goldenDuck.h);
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 12px sans-serif';
        ctx.fillText('100', goldenDuck.x + 14, goldenDuck.y + 22);
      } else {
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(goldenDuck.x, goldenDuck.y, goldenDuck.w, goldenDuck.h);
        ctx.fillStyle = '#333';
        ctx.font = '12px sans-serif';
        ctx.fillText('100', goldenDuck.x + 14, goldenDuck.y + 22);
      }
    }

    if (duck && duck.flyingAway) {
      ctx.globalAlpha = 0.8;
      if (imgDuck.complete && imgDuck.naturalWidth) ctx.drawImage(imgDuck, duck.x, duck.y, duck.w, duck.h);
      else { ctx.fillStyle = '#ff9800'; ctx.fillRect(duck.x, duck.y, duck.w, duck.h); }
      ctx.globalAlpha = 1;
    }
    if (goldenDuck && goldenDuck.flyingAway) {
      ctx.globalAlpha = 0.8;
      if (imgDuck.complete && imgDuck.naturalWidth) ctx.drawImage(imgDuck, goldenDuck.x, goldenDuck.y, goldenDuck.w, goldenDuck.h);
      else { ctx.fillStyle = '#ffd700'; ctx.fillRect(goldenDuck.x, goldenDuck.y, goldenDuck.w, goldenDuck.h); }
      ctx.globalAlpha = 1;
    }

    if (baby) {
      if (imgBaby.complete && imgBaby.naturalWidth) ctx.drawImage(imgBaby, baby.x, baby.y, baby.w, baby.h);
      else {
        ctx.fillStyle = '#ffb74d';
        ctx.fillRect(baby.x, baby.y, baby.w, baby.h);
        ctx.fillStyle = '#333';
        ctx.font = '12px sans-serif';
        ctx.fillText('+15', baby.x + 12, baby.y + baby.h / 2 + 4);
      }
    }

    if (plane) {
      if (imgPlane.complete && imgPlane.naturalWidth) {
        if (plane.vx > 0) ctx.save(), ctx.translate(plane.x + plane.w, plane.y), ctx.scale(-1, 1), ctx.drawImage(imgPlane, 0, 0, plane.w, plane.h), ctx.restore();
        else ctx.drawImage(imgPlane, plane.x, plane.y, plane.w, plane.h);
      } else {
        ctx.fillStyle = '#90a4ae';
        ctx.fillRect(plane.x, plane.y, plane.w, plane.h);
        ctx.fillStyle = '#333';
        ctx.font = '11px sans-serif';
        ctx.fillText('+25', plane.x + 18, plane.y + plane.h / 2 + 4);
      }
    }

    streamParticles.forEach(function(p) {
      ctx.fillStyle = 'rgba(100,200,255,' + (p.life / p.maxLife) + ')';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    });

    if (firing && state === 'playing') {
      var mainPoints = getStreamPointsWithAngle(aimAngle);
      ctx.strokeStyle = 'rgba(100,200,255,0.9)';
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(mainPoints[0].x, mainPoints[0].y);
      for (var i = 1; i < mainPoints.length; i++) ctx.lineTo(mainPoints[i].x, mainPoints[i].y);
      ctx.stroke();
      if (splitStreamUntil > Date.now()) {
        var leftPoints = getStreamPointsWithAngle(aimAngle - SPLIT_STREAM_OFFSET);
        ctx.strokeStyle = 'rgba(150,220,255,0.85)';
        ctx.beginPath();
        ctx.moveTo(leftPoints[0].x, leftPoints[0].y);
        for (var j = 1; j < leftPoints.length; j++) ctx.lineTo(leftPoints[j].x, leftPoints[j].y);
        ctx.stroke();
        var rightPoints = getStreamPointsWithAngle(aimAngle + SPLIT_STREAM_OFFSET);
        ctx.beginPath();
        ctx.moveTo(rightPoints[0].x, rightPoints[0].y);
        for (var k = 1; k < rightPoints.length; k++) ctx.lineTo(rightPoints[k].x, rightPoints[k].y);
        ctx.stroke();
      }
    }

    ctx.fillStyle = '#37474f';
    ctx.beginPath();
    ctx.ellipse(player.x, player.y + 8, 25, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#78909c';
    ctx.beginPath();
    ctx.arc(player.x, player.y, 18, 0, Math.PI * 2);
    ctx.fill();
    const nx = player.x + Math.cos(aimAngle) * 22;
    const ny = player.y + Math.sin(aimAngle) * 22;
    ctx.strokeStyle = '#546e7a';
    ctx.lineWidth = player.nozzleWidth;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(player.x, player.y);
    ctx.lineTo(nx, ny);
    ctx.stroke();

    comboPopups.forEach(function(c) {
      ctx.fillStyle = 'rgba(255,235,59,' + c.life + ')';
      ctx.font = 'bold 18px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(c.text, c.x, c.y);
    });
    ctx.textAlign = 'left';

    if (windUntil > Date.now()) {
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('WIND ' + (windForce > 0 ? '→' : '←'), W / 2, 50);
      ctx.textAlign = 'left';
    }
    if (splitStreamUntil > Date.now()) {
      ctx.fillStyle = 'rgba(255,193,7,0.8)';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Split Stream!', W / 2, 70);
      ctx.textAlign = 'left';
    }
    drawSplitStreamPickup();

    ctx.restore();
  }

  function tick(now) {
    const dt = now - lastTime;
    lastTime = now;
    update(dt);
    draw();
    if (state === 'playing') requestAnimationFrame(tick);
  }

  function startGame() {
    try { ensureAudio(); } catch (e) {}
    requestMotionPermission(function(ok) {
      motionPermissionGranted = ok;
      if (!ok) {
        try { alert('Motion access helps aim. You can still play with default aim.'); } catch (a) {}
      }
      document.getElementById('startBtn').style.display = 'none';
      document.getElementById('instructions').classList.add('hidden');
      state = 'playing';
      score = 0;
      timeLeft = 30;
      comboCount = 0;
      comboMultiplier = 1;
      targets = [];
      duck = null;
      goldenDuck = null;
      baby = null;
      plane = null;
      babyRespawnAt = 0;
      planeSpawnAccum = 0;
      splitStreamPickup = null;
      streamParticles = [];
      comboPopups = [];
      spawnAccum = 0;
      duckSpawnAccum = 0;
      goldenDuckSpawnAccum = 0;
      screenShake = 0;
      splitStreamUntil = 0;
      windUntil = 0;
      windForce = 0;
      shrinkFactor = 1;
      streamPower = 1;
      initBackgroundBubbles();
      bindOrientation();
      lastTime = performance.now();
      requestAnimationFrame(tick);

      document.getElementById('timer').textContent = timeLeft;
      document.getElementById('score').textContent = 'Score: ' + score;
      timerInterval = setInterval(function() {
        timeLeft--;
        document.getElementById('timer').textContent = timeLeft;
        document.getElementById('score').textContent = 'Score: ' + score;
        document.getElementById('combo').textContent = comboMultiplier > 1 ? 'x' + comboMultiplier + ' Combo!' : '';
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          endGame();
        }
      }, 1000);
    });
  }

  function endGame() {
    state = 'gameOver';
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = null;
    unbindOrientation();
    document.getElementById('gameOver').classList.add('show');
    document.getElementById('finalScore').textContent = 'Score: ' + score;
    document.getElementById('combo').textContent = '';
  }

  // Start button: support both click and touch so it works reliably on phones.
  var startBtn = document.getElementById('startBtn');
  function onStart() {
    if (state === 'playing') return;
    startGame();
  }
  startBtn.addEventListener('click', function(e) { e.preventDefault(); onStart(); });
  startBtn.addEventListener('touchend', function(e) {
    e.preventDefault();
    onStart();
  }, { passive: false });

  function showStartScreen() {
    document.getElementById('gameOver').classList.remove('show');
    document.getElementById('startBtn').style.display = 'block';
    document.getElementById('instructions').classList.remove('hidden');
    document.getElementById('timer').textContent = '30';
    document.getElementById('score').textContent = 'Score: 0';
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = null;
    state = 'idle';
  }
  document.getElementById('restartBtn').addEventListener('click', function(e) {
    e.preventDefault();
    showStartScreen();
  });
  document.getElementById('restartBtn').addEventListener('touchend', function(e) {
    e.preventDefault();
    showStartScreen();
  }, { passive: false });

  // Show mobile or desktop instructions on load
  (function() {
    var mobileEl = document.getElementById('instructionsMobile');
    var desktopEl = document.getElementById('instructionsDesktop');
    if (isTouchDevice) mobileEl.style.display = 'block'; else desktopEl.style.display = 'block';
  })();

})();
  </script>
</body>
</html>
