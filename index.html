<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1">
  <title>Arcade Toilet Target</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; touch-action: none; -webkit-tap-highlight-color: transparent; }
    #gameCanvas { display: block; width: 100%; height: 100%; background: #1a5f7a; }
    #ui { position: fixed; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 10; }
    #ui > * { pointer-events: auto; }
    #score { position: absolute; top: 12px; left: 12px; font: bold 24px/1 sans-serif; color: #fff; text-shadow: 0 1px 3px #000; }
    #timer { position: absolute; top: 12px; right: 12px; font: bold 24px/1 sans-serif; color: #ffeb3b; text-shadow: 0 1px 3px #000; }
    #combo { position: absolute; top: 12px; left: 50%; transform: translateX(-50%); font: bold 20px/1 sans-serif; color: #ff9800; text-shadow: 0 1px 3px #000; }
    #startBtn { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 16px 32px; font: bold 20px sans-serif; background: #4caf50; color: #fff; border: none; border-radius: 12px; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    #startBtn:active { transform: translate(-50%, -50%) scale(0.98); }
    #gameOver { position: absolute; left: 50%; top: 45%; transform: translate(-50%, -50%); text-align: center; display: none; }
    #gameOver.show { display: block; }
    #finalScore { font: bold 28px sans-serif; color: #fff; text-shadow: 0 2px 4px #000; margin-bottom: 12px; }
    #restartBtn { padding: 14px 28px; font: bold 18px sans-serif; background: #2196f3; color: #fff; border: none; border-radius: 10px; cursor: pointer; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="ui">
    <div id="score">Score: 0</div>
    <div id="timer">30</div>
    <div id="combo"></div>
    <button id="startBtn">Start (Allow Motion)</button>
    <div id="gameOver">
      <div id="finalScore">Score: 0</div>
      <button id="restartBtn">Play Again</button>
    </div>
  </div>

  <script>
(function() {
  'use strict';

  // ========== CANVAS & CONTEXT ==========
  // Fullscreen canvas for 60fps rendering; no external libraries.
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let W, H;

  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // ========== GAME STATE ==========
  let state = 'idle'; // idle | playing | gameOver
  let score = 0;
  let timeLeft = 30;
  let lastTime = 0;
  let comboCount = 0;
  let comboMultiplier = 1;
  let aimAngle = -Math.PI / 2;
  let firing = false;
  let streamParticles = [];
  let targets = [];
  let duck = null;
  let goldenDuck = null;
  let toiletBowl = { x: 0, y: 0, r: 55, moving: false, vx: 0 };
  let screenShake = 0;
  let turboUntil = 0;
  let windUntil = 0;
  let windForce = 0;
  let shrinkFactor = 1;
  let comboPopups = [];
  let backgroundBubbles = [];
  let spawnAccum = 0;
  let duckSpawnAccum = 0;
  let goldenDuckSpawnAccum = 0;
  let timerInterval = null;
  let motionPermissionGranted = false;

  // ========== IOS DEVICE ORIENTATION PERMISSION ==========
  // Required for iOS 13+: requestPermission must be called from a user gesture (Start button).
  function requestMotionPermission(cb) {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
        .then(function(permission) {
          motionPermissionGranted = permission === 'granted';
          if (cb) cb(motionPermissionGranted);
        })
        .catch(function() { if (cb) cb(false); });
    } else {
      motionPermissionGranted = true;
      if (cb) cb(true);
    }
  }

  // ========== TURBO STREAM POWERUP ==========
  // Floating collectible; hit with stream to temporarily increase speed and arc length.
  let turboPickup = null;
  function trySpawnTurboPickup() {
    if (turboPickup || turboUntil > Date.now()) return;
    if (Math.random() > 0.008) return;
    turboPickup = {
      x: 30 + Math.random() * (W - 60),
      y: H * 0.3 + Math.random() * H * 0.3,
      r: 18
    };
  }
  function updateTurboPickup(dt) {
    if (!turboPickup || !firing) return;
    const points = getStreamPoints();
    for (let i = 0; i < points.length; i++) {
      if (hitTestCircle(points[i].x, points[i].y, turboPickup.x, turboPickup.y, turboPickup.r)) {
        turboUntil = Date.now() + 5000;
        turboPickup = null;
        soundGolden();
        break;
      }
    }
  }
  function drawTurboPickup() {
    if (!turboPickup) return;
    ctx.fillStyle = 'rgba(255,193,7,0.9)';
    ctx.beginPath();
    ctx.arc(turboPickup.x, turboPickup.y, turboPickup.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('TURBO', turboPickup.x, turboPickup.y + 5);
    ctx.textAlign = 'left';
  }

  // ========== PLAYER (BOTTOM CENTER) ==========
  const player = { x: 0, y: 0, baseY: 0, nozzleWidth: 12 };

  function updatePlayerPosition() {
    player.x = W / 2;
    player.baseY = H - 40;
    player.y = player.baseY;
  }

  // --- STREAM PHYSICS (CURVED, GRAVITY) ---
  const GRAVITY = 0.28;
  const STREAM_SPEED = 14;
  const SEGMENT_DIST = 8;
  const MAX_SEGMENTS = 35;

  function getStreamSpeed() {
    return turboUntil > Date.now() ? STREAM_SPEED * 1.6 : STREAM_SPEED;
  }

  function getStreamSegments() {
    return turboUntil > Date.now() ? Math.floor(MAX_SEGMENTS * 1.4) : MAX_SEGMENTS;
  }

  function getStreamPoints() {
    const speed = getStreamSpeed();
    const maxSeg = getStreamSegments();
    const points = [];
    let x = player.x;
    let y = player.y;
    let vx = Math.cos(aimAngle) * speed;
    let vy = Math.sin(aimAngle) * speed;
    points.push({ x, y });
    for (let i = 0; i < maxSeg; i++) {
      vy += GRAVITY;
      vx += windForce * 0.02;
      x += vx;
      y += vy;
      points.push({ x, y });
    }
    return points;
  }

  // ========== TARGETS (FLOATING BALLS) ==========
  // Balls bounce off edges; +10 hit, -5 miss; radius can shrink over time (difficulty).
  const TARGET_BASE_R = 20;
  const TARGET_MIN_R = 8;

  function spawnTarget() {
    const r = Math.max(TARGET_MIN_R, TARGET_BASE_R * shrinkFactor);
    targets.push({
      x: r + Math.random() * (W - 2 * r),
      y: r + Math.random() * (H * 0.5 - 2 * r),
      r,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      isGolden: false
    });
  }

  function hitTestCircle(ax, ay, cx, cy, cr) {
    return (ax - cx) ** 2 + (ay - cy) ** 2 <= cr * cr;
  }

  function hitTestRect(ax, ay, rx, ry, rw, rh) {
    return ax >= rx && ax <= rx + rw && ay >= ry && ay <= ry + rh;
  }

  // --- DUCK (OBSTACLE) ---
  const DUCK_W = 50;
  const DUCK_H = 35;

  function spawnDuck() {
    if (duck && !duck.flyingAway) return;
    const fromLeft = Math.random() > 0.5;
    duck = {
      x: fromLeft ? -DUCK_W - 20 : W + 20,
      y: H * 0.25 + Math.random() * H * 0.25,
      w: DUCK_W,
      h: DUCK_H,
      vx: fromLeft ? 5 : -5,
      flyingAway: false,
      isGolden: false
    };
  }

  function spawnGoldenDuck() {
    if (goldenDuck) return;
    const fromLeft = Math.random() > 0.5;
    goldenDuck = {
      x: fromLeft ? -DUCK_W - 20 : W + 20,
      y: H * 0.2 + Math.random() * H * 0.2,
      w: DUCK_W,
      h: DUCK_H,
      vx: fromLeft ? 4 : -4,
      flyingAway: false
    };
  }

  // ========== TOILET BOWL TARGET ==========
  // Circular zone; +20 hit; splash on miss; can move horizontally (random spawn).
  function initToiletBowl() {
    toiletBowl.x = W / 2;
    toiletBowl.y = H - 120;
    toiletBowl.r = 55;
    toiletBowl.moving = false;
    toiletBowl.vx = 0;
  }

  function updateToiletBowl(dt) {
    if (!toiletBowl.moving) {
      if (Math.random() < 0.002) {
        toiletBowl.moving = true;
        toiletBowl.vx = (Math.random() - 0.5) * 2;
      }
    } else {
      toiletBowl.x += toiletBowl.vx * dt * 0.06;
      if (toiletBowl.x < toiletBowl.r || toiletBowl.x > W - toiletBowl.r) toiletBowl.vx *= -1;
    }
  }

  // ========== AUDIO (SIMPLE WEB AUDIO) ==========
  // No external assets; oscillators for hit, miss, quack, splash, golden.
  let audioCtx = null;

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  function playTone(freq, duration, type) {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.type = type || 'sine';
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + duration);
  }

  function soundHit() {
    playTone(600, 0.08, 'square');
    setTimeout(function() { playTone(800, 0.06, 'square'); }, 50);
  }

  function soundMiss() {
    playTone(200, 0.15, 'sawtooth');
  }

  function soundQuack() {
    playTone(400, 0.1, 'sawtooth');
    setTimeout(function() { playTone(350, 0.12, 'sawtooth'); }, 80);
  }

  function soundSplash() {
    playTone(150, 0.2, 'triangle');
    playTone(100, 0.15, 'sine');
  }

  function soundGolden() {
    playTone(880, 0.1, 'sine');
    playTone(1320, 0.12, 'sine');
  }

  // --- VIBRATION ---
  function vibrateHit() {
    if (navigator.vibrate) navigator.vibrate(30);
  }

  function vibrateDuck() {
    if (navigator.vibrate) navigator.vibrate([40, 30, 40]);
  }

  // ========== PARTICLE HELPERS ==========
  // Splash particles and combo popups (bonus).
  function addSplashParticles(x, y, count) {
    for (let i = 0; i < count; i++) {
      streamParticles.push({
        x, y,
        vx: (Math.random() - 0.5) * 8,
        vy: -Math.random() * 6 - 2,
        life: 0.5 + Math.random() * 0.4,
        maxLife: 1,
        r: 3 + Math.random() * 4
      });
    }
  }

  function addComboPopup(x, y, text) {
    comboPopups.push({ x, y, text, life: 1, vy: -1.5 });
  }

  // --- BACKGROUND BUBBLES ---
  function initBackgroundBubbles() {
    backgroundBubbles = [];
    for (let i = 0; i < 15; i++) {
      backgroundBubbles.push({
        x: Math.random() * W,
        y: Math.random() * H,
        r: 4 + Math.random() * 12,
        vy: -0.3 - Math.random() * 0.5,
        opacity: 0.2 + Math.random() * 0.2
      });
    }
  }

  function updateBackgroundBubbles(dt) {
    backgroundBubbles.forEach(function(b) {
      b.y += b.vy * dt * 0.06;
      if (b.y < -b.r) { b.y = H + b.r; b.x = Math.random() * W; }
    });
  }

  // ========== STREAM vs WORLD COLLISION ==========
  // Circle collision for balls and bowl; rectangle for duck. Order: duck, golden duck, balls, bowl.
  function checkStreamCollisions(points) {
    let hitSomething = false;
    for (let i = 1; i < points.length; i++) {
      const p = points[i];

      if (duck && !duck.flyingAway && hitTestRect(p.x, p.y, duck.x, duck.y, duck.w, duck.h)) {
        hitSomething = true;
        score = Math.max(0, score - 10);
        screenShake = 15;
        soundQuack();
        vibrateDuck();
        duck.flyingAway = true;
        duck.vx = duck.vx > 0 ? 12 : -12;
        duck.vy = -4;
        comboCount = 0;
        comboMultiplier = 1;
        break;
      }

      if (goldenDuck && !goldenDuck.flyingAway && hitTestRect(p.x, p.y, goldenDuck.x, goldenDuck.y, goldenDuck.w, goldenDuck.h)) {
        hitSomething = true;
        score += 100 * comboMultiplier;
        soundGolden();
        vibrateHit();
        addComboPopup(goldenDuck.x + goldenDuck.w / 2, goldenDuck.y, '+100');
        goldenDuck.flyingAway = true;
        goldenDuck.vx = goldenDuck.vx > 0 ? 14 : -14;
        goldenDuck.vy = -5;
        comboCount++;
        comboMultiplier = Math.min(5, 1 + Math.floor(comboCount / 2));
        break;
      }

      for (let t = targets.length - 1; t >= 0; t--) {
        const ball = targets[t];
        if (hitTestCircle(p.x, p.y, ball.x, ball.y, ball.r)) {
          hitSomething = true;
          score += 10 * comboMultiplier;
          soundHit();
          vibrateHit();
          addSplashParticles(ball.x, ball.y, 8);
          addComboPopup(ball.x, ball.y, '+' + (10 * comboMultiplier));
          targets.splice(t, 1);
          comboCount++;
          comboMultiplier = Math.min(5, 1 + Math.floor(comboCount / 2));
          break;
        }
      }
      if (hitSomething) break;

      if (hitTestCircle(p.x, p.y, toiletBowl.x, toiletBowl.y, toiletBowl.r)) {
        hitSomething = true;
        score += 20 * comboMultiplier;
        soundHit();
        vibrateHit();
        addSplashParticles(toiletBowl.x, toiletBowl.y, 12);
        addComboPopup(toiletBowl.x, toiletBowl.y - toiletBowl.r, '+' + (20 * comboMultiplier));
        comboCount++;
        comboMultiplier = Math.min(5, 1 + Math.floor(comboCount / 2));
        break;
      }
    }

    if (!hitSomething && points.length > 5) {
      const last = points[points.length - 1];
      if (last.y > H * 0.6) {
        addSplashParticles(last.x, last.y, 6);
        soundSplash();
        score = Math.max(0, score - 5);
        comboCount = 0;
        comboMultiplier = 1;
      }
    }
  }

  // --- INPUT ---
  let orientationHandler = null;

  function bindOrientation() {
    orientationHandler = function(e) {
      if (state !== 'playing' || e.gamma == null) return;
      const g = Math.max(-60, Math.min(60, e.gamma));
      aimAngle = -Math.PI / 2 + (g / 60) * Math.PI * 0.6;
    };
    window.addEventListener('deviceorientation', orientationHandler);
  }

  function unbindOrientation() {
    if (orientationHandler) window.removeEventListener('deviceorientation', orientationHandler);
    orientationHandler = null;
  }

  canvas.addEventListener('touchstart', function(e) {
    e.preventDefault();
    if (state === 'playing') firing = true;
  });
  canvas.addEventListener('touchend', function(e) {
    e.preventDefault();
    firing = false;
  });
  canvas.addEventListener('mousedown', function() { if (state === 'playing') firing = true; });
  canvas.addEventListener('mouseup', function() { firing = false; });
  canvas.addEventListener('mouseleave', function() { firing = false; });

  // ========== GAME LOOP ==========
  // requestAnimationFrame at 60fps; update then draw.
  function update(dt) {
    if (state !== 'playing') return;

    updatePlayerPosition();
    updateToiletBowl(dt);
    updateBackgroundBubbles(dt);

    if (screenShake > 0) screenShake -= dt * 0.2;
    if (screenShake < 0) screenShake = 0;

    if (turboUntil > 0 && turboUntil < Date.now()) turboUntil = 0;
    if (windUntil > 0 && windUntil < Date.now()) { windUntil = 0; windForce = 0; }

    shrinkFactor = Math.max(0.4, 1 - (30 - timeLeft) / 30 * 0.6);

    if (firing) {
      const points = getStreamPoints();
      checkStreamCollisions(points);
    }

    for (let i = 0; i < targets.length; i++) {
      const t = targets[i];
      t.x += t.vx;
      t.y += t.vy;
      if (t.x <= t.r || t.x >= W - t.r) t.vx *= -1;
      if (t.y <= t.r || t.y >= H - t.r) t.vy *= -1;
    }

    if (duck) {
      if (duck.flyingAway) {
        duck.vy += 0.3;
        duck.x += duck.vx;
        duck.y += duck.vy;
        if (duck.y > H + 50 || duck.x < -100 || duck.x > W + 100) duck = null;
      } else {
        duck.x += duck.vx;
        if (duck.x < -DUCK_W - 50 || duck.x > W + 50) duck = null;
      }
    }

    if (goldenDuck) {
      if (goldenDuck.flyingAway) {
        goldenDuck.vy += 0.25;
        goldenDuck.x += goldenDuck.vx;
        goldenDuck.y += goldenDuck.vy;
        if (goldenDuck.y > H + 50 || goldenDuck.x < -100 || goldenDuck.x > W + 100) goldenDuck = null;
      } else {
        goldenDuck.x += goldenDuck.vx;
        if (goldenDuck.x < -DUCK_W - 50 || goldenDuck.x > W + 50) goldenDuck = null;
      }
    }

    for (let i = streamParticles.length - 1; i >= 0; i--) {
      const p = streamParticles[i];
      p.x += p.vx * dt * 0.06;
      p.y += p.vy * dt * 0.06;
      p.vy += 0.15 * dt * 0.06;
      p.life -= dt * 0.008;
      if (p.life <= 0) streamParticles.splice(i, 1);
    }

    for (let i = comboPopups.length - 1; i >= 0; i--) {
      const c = comboPopups[i];
      c.y += c.vy * dt * 0.06;
      c.life -= dt * 0.012;
      if (c.life <= 0) comboPopups.splice(i, 1);
    }

    trySpawnTurboPickup();
    updateTurboPickup(dt);

    spawnAccum += dt * (0.5 + (30 - timeLeft) / 30 * 1.5);
    while (spawnAccum > 1) {
      spawnAccum -= 1;
      spawnTarget();
    }

    duckSpawnAccum += dt * 0.08;
    if (duckSpawnAccum > 1 && !duck) {
      duckSpawnAccum = 0;
      spawnDuck();
    }

    goldenDuckSpawnAccum += dt * 0.015;
    if (goldenDuckSpawnAccum > 1 && !goldenDuck) {
      goldenDuckSpawnAccum = 0;
      spawnGoldenDuck();
    }

    if (Math.random() < 0.001 && windUntil < Date.now()) {
      windUntil = Date.now() + 3000;
      windForce = (Math.random() - 0.5) * 8;
    }
  }

  function draw() {
    let dx = 0, dy = 0;
    if (screenShake > 0) {
      dx = (Math.random() - 0.5) * screenShake;
      dy = (Math.random() - 0.5) * screenShake;
    }
    ctx.save();
    ctx.translate(dx, dy);

    ctx.fillStyle = '#1a5f7a';
    ctx.fillRect(0, 0, W, H);

    backgroundBubbles.forEach(function(b) {
      ctx.fillStyle = 'rgba(255,255,255,' + b.opacity + ')';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    });

    ctx.fillStyle = '#0d3d4d';
    ctx.beginPath();
    ctx.ellipse(toiletBowl.x, toiletBowl.y + 15, toiletBowl.r * 1.1, toiletBowl.r * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#1565c0';
    ctx.beginPath();
    ctx.arc(toiletBowl.x, toiletBowl.y, toiletBowl.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#0d47a1';
    ctx.lineWidth = 4;
    ctx.stroke();

    targets.forEach(function(t) {
      ctx.fillStyle = t.isGolden ? '#ffd700' : '#ff5722';
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
    });

    if (duck && !duck.flyingAway) {
      ctx.fillStyle = '#ff9800';
      ctx.fillRect(duck.x, duck.y, duck.w, duck.h);
      ctx.fillStyle = '#000';
      ctx.font = '14px sans-serif';
      ctx.fillText('QUACK', duck.x + 8, duck.y + 22);
    }

    if (goldenDuck && !goldenDuck.flyingAway) {
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(goldenDuck.x, goldenDuck.y, goldenDuck.w, goldenDuck.h);
      ctx.fillStyle = '#333';
      ctx.font = '12px sans-serif';
      ctx.fillText('100', goldenDuck.x + 14, goldenDuck.y + 22);
    }

    if (duck && duck.flyingAway) {
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = '#ff9800';
      ctx.fillRect(duck.x, duck.y, duck.w, duck.h);
      ctx.globalAlpha = 1;
    }
    if (goldenDuck && goldenDuck.flyingAway) {
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(goldenDuck.x, goldenDuck.y, goldenDuck.w, goldenDuck.h);
      ctx.globalAlpha = 1;
    }

    streamParticles.forEach(function(p) {
      ctx.fillStyle = 'rgba(100,200,255,' + (p.life / p.maxLife));
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    });

    if (firing && state === 'playing') {
      const points = getStreamPoints();
      ctx.strokeStyle = 'rgba(100,200,255,0.9)';
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
      ctx.stroke();
    }

    ctx.fillStyle = '#37474f';
    ctx.beginPath();
    ctx.ellipse(player.x, player.y + 8, 25, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#78909c';
    ctx.beginPath();
    ctx.arc(player.x, player.y, 18, 0, Math.PI * 2);
    ctx.fill();
    const nx = player.x + Math.cos(aimAngle) * 22;
    const ny = player.y + Math.sin(aimAngle) * 22;
    ctx.strokeStyle = '#546e7a';
    ctx.lineWidth = player.nozzleWidth;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(player.x, player.y);
    ctx.lineTo(nx, ny);
    ctx.stroke();

    comboPopups.forEach(function(c) {
      ctx.fillStyle = 'rgba(255,235,59,' + c.life + ')';
      ctx.font = 'bold 18px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(c.text, c.x, c.y);
    });
    ctx.textAlign = 'left';

    if (windUntil > Date.now()) {
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('WIND ' + (windForce > 0 ? '→' : '←'), W / 2, 50);
      ctx.textAlign = 'left';
    }
    if (turboUntil > Date.now()) {
      ctx.fillStyle = 'rgba(255,193,7,0.8)';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('TURBO', W / 2, 70);
      ctx.textAlign = 'left';
    }
    drawTurboPickup();

    ctx.restore();
  }

  function tick(now) {
    const dt = now - lastTime;
    lastTime = now;
    update(dt);
    draw();
    if (state === 'playing') requestAnimationFrame(tick);
  }

  function startGame() {
    requestMotionPermission(function(ok) {
      motionPermissionGranted = ok;
      if (!ok) {
        alert('Motion access helps aim. You can still play with default aim.');
      }
      document.getElementById('startBtn').style.display = 'none';
      state = 'playing';
      score = 0;
      timeLeft = 30;
      comboCount = 0;
      comboMultiplier = 1;
      targets = [];
      duck = null;
      goldenDuck = null;
      streamParticles = [];
      comboPopups = [];
      spawnAccum = 0;
      duckSpawnAccum = 0;
      goldenDuckSpawnAccum = 0;
      screenShake = 0;
      turboUntil = 0;
      windUntil = 0;
      windForce = 0;
      shrinkFactor = 1;
      initToiletBowl();
      initBackgroundBubbles();
      bindOrientation();
      lastTime = performance.now();
      requestAnimationFrame(tick);

      timerInterval = setInterval(function() {
        timeLeft--;
        document.getElementById('timer').textContent = timeLeft;
        document.getElementById('score').textContent = 'Score: ' + score;
        document.getElementById('combo').textContent = comboMultiplier > 1 ? 'x' + comboMultiplier + ' Combo!' : '';
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          endGame();
        }
      }, 1000);
    });
  }

  function endGame() {
    state = 'gameOver';
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = null;
    unbindOrientation();
    document.getElementById('gameOver').classList.add('show');
    document.getElementById('finalScore').textContent = 'Score: ' + score;
    document.getElementById('combo').textContent = '';
  }

  document.getElementById('startBtn').addEventListener('click', function() {
    ensureAudio();
    startGame();
  });

  document.getElementById('restartBtn').addEventListener('click', function() {
    document.getElementById('gameOver').classList.remove('show');
    document.getElementById('startBtn').style.display = 'block';
    document.getElementById('timer').textContent = '30';
    document.getElementById('score').textContent = 'Score: 0';
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = null;
  });

})();
  </script>
</body>
</html>
